package voteListener;

import java.io.*;
import java.net.*;
import java.util.ArrayList;

public class VoteListener {

	HttpURLConnection connection;
	
	File votersList = new File("Voters_list.xml");
	File topsList = new File("Tops.config");
	
	final String Top1 = "http://minecraftservers.org/vote/440795";
	final String top1UniqueTag = "table class=" + "\"" + "server-info voters-info" + "\"";
	
	final String Top2 = "https://topcraft.ru/servers/1479/statistics/";
	final String top2UniqueTag = "div class=" + "\"" + "col-xs-6 voterStats" + "\"" + " data-stats-type=" + "\"" + "current_month" + "\"";
	final String top2TableTag = "tbody class=\"voters\"";
	
	ArrayList<Voter> voters = new ArrayList<Voter>();
	
	public VoteListener()
	{
//		System.out.print((byte) ' ');
		
//		topDataAnalyze(top1UniqueTag, getDataFromTop(Top1));
		topDataAnalyze(top2UniqueTag, top2TableTag, getDataFromTop(Top2));
	}
	
	byte[] getDataFromTop(String path)
	{
		byte result[];
		int count = 0;
		byte b[] = new byte[1024 * 64];
		byte i = 0;
		
		try 
		{
			URL url = new URL(path);
			connection = (HttpURLConnection) url.openConnection();
			connection.addRequestProperty("User-Agent", "VoteListener_v0.1 FreeMinerServers 20/02/2016");			
			connection.setRequestMethod("GET");
		}
		catch(IOException Ex)
		{
			Ex.printStackTrace();
		}
		
		try(InputStream input = connection.getInputStream())
		{
			while(i != -1)
			{
				i = (byte) input.read();
				b[count] = i;
				count++;
			}
		} 
		catch (Exception e)
		{
			e.printStackTrace();
		}
		finally
		{
			result = new byte[count];
			
			for(int j = 0; j < count; j++)
			{
				result[j] = b[j];
			}
		}
		
		return result;
	}
	
	// --- Метод для скачивания информации из топа с последующим ее анализом ---
	/*
	 * Скачивает  и анализирует с помощью приведенных ниже методов Html страницу.
	 * uniqueTag - переменная задает тэг в пределах которго хранится таблица с голосующими. 
	 */
	
	void topDataAnalyze(String uniqueTag, byte[] scanResult)
	{		
		getVotersFromArray(HtmlDataAnalyze(scanResult, "table class=" + "\"" + "server-info voters-info" + "\"", false), 1, 2);
	}
	
	// --- Перегруженная верся предыдущего метода ---
	/*
	 * На случай если на сайте есть несколько таблиц и уникальность конкретной можно определить только по внешнему контейнеру.
	 * tableTag - в данном случе задает гряницы для содержимого таблицы,
	 * а uniqueTag - уникальное имя контейнера в котором храниться нужная таблица.
	 */
	
	void topDataAnalyze(String uniqueTag, String tableTag, byte[] scanResult)
	{		
		getVotersFromArray(HtmlDataAnalyze(HtmlDataAnalyze(scanResult, uniqueTag, false), tableTag, false), 2, 3);
			
	}
	
	// --- Расширитель массива ---
	/*
	 * Расширяет переданный массив на указанное количество в expandSize количество ячеек и возвращает новый, переписывая в него информацию
	 * из переданного - expandableArray.
	 */
	
	byte[] arrayExpand(byte[] expandableArray, int expandSize)
	{
		byte[] tempArray = new byte[expandableArray.length + expandSize];	//Массив которы будем передавать сразу объявляем нужного размера.
		for(int i = 0; i < expandableArray.length; i++)	//Записываем в него старый массив
		{
			tempArray[i] = expandableArray[i];	//Переписать нужно каждую ячейку старого массива
		}
		
//		System.out.println("Array expanded to " + tempArray.length + " elements");
		return tempArray;
	}

	
	// --- Анализатор HTML файлов ---
	/*
	 * Анализирует байтовый массив - analyzingArray, считанный c интернет-страницы и вытаскивает из него информацию,
	 * которая находится между тэгами - dataBeginTag и dataEndTag. В методе предусмотренн вариант когда информацию нужно считать вместе с ключевыми
	 * тэгами, управляется флагом - withKeyTags  
	 * Переменные метода:
	 * tagStarts - Маркер начала тэга. Сохраняет номер ячейки массива с сохраненным в ней символом '<'. Нужен для будущего сравнения с эталоном.
	 * tagEnds - Марке для конца тэга, соответственно '>'. Обозначает конец тэга.
	 * count - В этом методе, счетчик итераций записи в итоговый массив, управляет условием цикла при записи итогового массива.
	 * dataBeginPosition - маркер ячейк массива, с которого нужно начать запись в итоговый массив
	 * scanedData - сам итоговый массив
	 * tagOpend - Флаг, указывает на то, что считывающий курсор находится внутри тэга. Нужен для считывания тэга и его будущего сравнения с эталоном.
	 * Так же нужен для того, чтобы избежать случайной стихийной записи в сравнивающий массив, в случае если символ открытя тэга попадется в тексте отдельно.
	 */
	
	byte[] HtmlDataAnalyze(byte[] array, String dataBeginTag, boolean withKeyTags)
	{
		int tagStarts = 0, tagEnds = 0, count = 0, dataBeginPos = 0;
		String dataEndTag = getEndTag(dataBeginTag);
		byte[] scannedData = new byte[0];
		boolean tagOpened = false;
		boolean requiredData = false;
		
		for(int nowCursor = 0; nowCursor < array.length; nowCursor++) //основной цикл
		{
			if(array[nowCursor] == 60 && !tagOpened) //Проверяет не является ли элемент массива символом '<'
			{
				tagOpened = true;  
				tagStarts = nowCursor + 1; //Номер ячейки с которой нужно будет начать запись. +1 для того чтобы не записыват в массив символ '<'
			}
			else if(array[nowCursor] == 62 && tagOpened) //Проверяет, закрылся ли тэг, сравнивая его с символом '>'
			{
				tagEnds = nowCursor; //Запоминает положение курсора для будущего сравнения
				tagOpened = false;	
				
				char compare[] = new char[tagEnds - tagStarts]; //Инициализация массива для сравнения
				
				for(int n = 0; n < tagEnds - tagStarts; n++) //Запись
				{
					compare[n] = (char) array[tagStarts + n];
				}
				
				if(new String(compare).equals(dataBeginTag)) //Собственно само сравнение, в случае успеха установится маркер начала искомой информации
				{
//					System.out.println("Data marker seccesfuly founded!");
					if(withKeyTags) dataBeginPos = tagStarts - 1; //Этот вариант сработает если нужно записать информацию вместе с ключевыми тэгами
					else dataBeginPos = nowCursor + 1; // А это если ключевые тэги не нужны
					requiredData = true;
				}
				
				if(new String(compare).equals(dataEndTag) && requiredData == true)
				{
					if(withKeyTags) //Запись вместе с тэгами
						{
							scannedData = arrayExpand(scannedData, tagEnds - dataBeginPos + 1);	//Метод расширяющий массив, смотреть выше
							for(int g = dataBeginPos; g < tagEnds + 1; g++) //Цикл записи в итоговый массив, =1 для записи символа '>'б иначе пропистит
							{
//								System.out.print((char) array[g]);
//								System.out.print("|" + count + ":");
								scannedData[count] = array[g]; //Тут можно увидеть как задействован счетчик итогового массива.
								count++;	//Без него информацию не получилось бы записать в один массив.
							}
						}
					else //Запись без тэгов. -2 устанавливает последний элемент перед символом "<'.
						{
							scannedData = arrayExpand(scannedData, tagStarts - dataBeginPos - 2);
							for(int g = dataBeginPos; g < tagStarts - 2; g++)
							{
//								System.out.print((char) array[g]);
//								System.out.print("|" + count + ":");
								scannedData[count] = array[g];
								count++;
							}
						}
					
					System.out.println("Data position captured!");
					System.out.println();
					requiredData = false;
				}
			}
			else if(nowCursor - tagStarts > 128 && tagOpened) tagOpened = false;
		}
		
		return scannedData;
	}
	
	// --- Метод для определения закрывающего тэга ---
	/*
	 * Счетчик count сохраняет длинну ключевого тэга.
	 * Когда x определяется как пробел, цикл заканчивается.
	 */
	
	String getEndTag(String beginTag)
	{
		int count = 0;
		for(char x : beginTag.toCharArray())	//Усовершенствованная верся цикла for - цикл for each в исполнении джава
		{
			if(x != ' ') count++;
			else break;
		}
		return ("/" + beginTag.substring(0, count));	// метод substring возвращает только кусочек beginTeg-а соответствующий ключевому. 
	}
	
	// --- Метод для удаления тэгов ---
	/*
	 * Работает независимо от того какой тэг.
	 * После выполнения возвращает текст который находился за пределами любого тэга.
	 */
	
	String getDataFromTag(byte[] array)
	{
		String resultStr = "";
		int count = 0, startPos = 0;
		String executedStr = new String(array);
		
		for(char x : executedStr.toCharArray())	//Усовершенствованная верся цикла for - цикл for each на языке java
		{
			System.out.print(x);
			if(x != '<' && count == 0)
			{
				startPos = count;
				count++;
			}
			else if(x == '<' && count == 0) 
			{
				count++;
			}
			else if(x == '>') 
			{
				startPos = count + 1;
				count++;
			}
			else if(x == '<' && count != 0) 
			{	
				resultStr.concat(executedStr.substring(startPos, count));
				count++;
			}
			else if(count == executedStr.toCharArray().length)
			{
				resultStr.concat(executedStr.substring(startPos, count));
			}
			
		}
		return resultStr;
	}
	
	// --- Считыватель голосов ---
	
	ArrayList<Voter> getVotersFromArray(byte[] array, int nickNameColumnNo, int votesColumnNo)
	{
		ArrayList<Voter> detectedVoters = new ArrayList<Voter>(); 
		
		String rowTag = "<tr>";
		String rowEndTag = "</tr>";
		
		
		byte[] scannedData = new byte[0];
		
		for(int cursorPos = 0, tagBegin = 0, tagEnd = 0, dataBeginPos = 0; cursorPos < array.length; cursorPos++)
		{
			if(array[cursorPos] == 60)
			{
				tagBegin = cursorPos;
			}
			else if(array[cursorPos] == 62)
			{
				tagEnd = cursorPos + 1;
				char compare[] = new char[tagEnd - tagBegin]; 
				
				for(int n = 0; n < compare.length; n++)
				{
					
					compare[n] = (char) array[tagBegin + n];
				}
				if(new String(compare).equals(rowTag)) 
				{
					dataBeginPos = cursorPos + 1;
				}
				
				if(new String(compare).equals(rowEndTag))
				{
					int count = 0;
					scannedData = arrayExpand(scannedData, tagBegin - dataBeginPos - 1);
					
					for(int g = dataBeginPos; g < tagBegin - 1; g++) 
					{
//						System.out.print((char) array[g]);
						scannedData[count] = array[g]; 
						count++;
					}
					detectedVoters.add(getVoterFromRaw(scannedData, nickNameColumnNo, votesColumnNo));
				}
			}
		}
		return detectedVoters;
	}
	
	// --- Метод извлекает нужные одной строки таблицы ---
	
	Voter getVoterFromRaw(byte[] array, int nickNameColumnNo, int votesColumnNo)
	{
		String columnTag = "<td>";
		String columnEndTag = "</td>";
		int columnNo = 1;
		byte[] scannedData = new byte[0];
		
		for(int cursorPos = 0, tagBegin = 0, tagEnd = 0, dataBeginPos = 0; cursorPos < array.length; cursorPos++)
		{
			if(array[cursorPos] == 60)
			{
				tagBegin = cursorPos;
			}
			else if(array[cursorPos] == 62)
			{
				tagEnd = cursorPos + 1;
				
				char compare[] = new char[tagEnd - tagBegin]; 
				
				for(int n = 0; n < compare.length; n++)
				{
					compare[n] = (char) array[tagBegin + n];
				}
				
				if(new String(compare).equals(columnTag)) dataBeginPos = cursorPos + 1;
				
				if(new String(compare).equals(columnEndTag) && columnNo == nickNameColumnNo)
				{
					int count = 0;
					scannedData = arrayExpand(scannedData, tagBegin - dataBeginPos);
					
					for(int g = dataBeginPos; g < tagBegin; g++) 
					{
//						System.out.print((char) array[g]);
						scannedData[count] = array[g]; 
						count++;		
					}
					
					columnNo++;
					System.out.print(": ");
				} 
				else if(new String(compare).equals(columnEndTag) && columnNo == votesColumnNo)
				{
					int count = 0;
					scannedData = arrayExpand(scannedData, tagBegin - dataBeginPos);
					
					for(int g = dataBeginPos; g < tagBegin; g++) 
					{
//						System.out.print((char) array[g]);
						scannedData[count] = array[g]; 
						count++;
					}
					System.out.println();
					columnNo++;
				}
				else if(new String(compare).equals(columnEndTag) && columnNo != votesColumnNo && columnNo != nickNameColumnNo)
				{
					columnNo++;
				}
			}
			
		}
		
		return null;
	}
	
	// --- Загрузка списка из файла
	
	void downloadVoterFromFile(File votersList)
	{
		if(votersList.exists())
		{
			
		}
		else
		{
			try
			{
				votersList.createNewFile();
			}
			catch(IOException Ex)
			{
				Ex.printStackTrace();
			}
			finally
			{
				System.out.println("Voters list is empty");
			}
		}
	}
	
	void VotersInfo(Voter voter)
	{
		
	}
	
	// --- Проверяет есть ли пользователь в таблице ---
	
	int voterCheck(String nickName)
	{
		for(int voterNo = 0; voterNo < voters.size() && voters.get(0) != null; voterNo++)
		{
			Voter vCheck = voters.get(voterNo);
			if(vCheck.getName() == nickName)
			{
				return voterNo;
			}
		}
		
		return -1;
	}
}

// --- Класс для хранения данных о голосующих ---

class Voter
{
	final String nickName;
	int voteCount;
	
	Voter(String nickName, int voteCount)
	{
		this.nickName = nickName;
		this.voteCount = voteCount;
	}
	
	String getName()
	{
		return nickName;
	}
	
	int getVoteCount()
	{
		return voteCount;
	}
	
	void changeVoteCount(int Value)
	{
		voteCount += Value;
	}
}